package component

import (
	"encoding/json"
	"net/url"
)

// csrfVals returns JSON string for hx-vals with CSRF token.
// Uses json.Marshal to ensure proper escaping of special characters.
func csrfVals(token string) string {
	data := map[string]string{"csrf_token": token}
	b, _ := json.Marshal(data)
	return string(b)
}

// getMessageID returns a stable ID for the message element.
// Empty msgID returns empty string (no id attribute rendered).
func getMessageID(msgID string) string {
	if msgID == "" {
		return ""
	}
	return "message-" + msgID
}

// messageIDAttrs returns a templ.Attributes map with id if msgID is non-empty.
// This avoids rendering empty id="" attributes which is invalid HTML.
func messageIDAttrs(msgID string) templ.Attributes {
	if msgID == "" {
		return nil
	}
	return templ.Attributes{"id": "message-" + msgID}
}

// buildSSEConnectURL constructs the SSE connect URL with properly encoded parameters.
// The query is URL-encoded to safely handle special characters and non-ASCII text.
func buildSSEConnectURL(messageID, sessionID, query string) string {
	params := url.Values{}
	params.Set("msgId", messageID)
	params.Set("session_id", sessionID)
	params.Set("query", query)
	return "/genui/stream?" + params.Encode()
}

// SkeletonLoader renders a loading skeleton for streaming messages.
templ SkeletonLoader() {
	<div class="flex flex-col gap-3">
		<div class="flex items-center gap-1.5">
			<div class="size-2 rounded-full bg-indigo-400 animate-bounce"></div>
			<div class="size-2 rounded-full bg-indigo-400 animate-bounce animation-delay-200"></div>
			<div class="size-2 rounded-full bg-indigo-400 animate-bounce animation-delay-400"></div>
		</div>
		<div class="space-y-2">
			<div class="h-3 bg-white/10 rounded animate-pulse w-3/4"></div>
			<div class="h-3 bg-white/10 rounded animate-pulse w-full"></div>
			<div class="h-3 bg-white/10 rounded animate-pulse w-5/6"></div>
		</div>
	</div>
}

// AIAvatar renders the AI assistant avatar icon.
templ AIAvatar() {
	<div class="flex size-8 shrink-0 items-center justify-center rounded-lg border border-white/10 bg-indigo-500/10">
		<span class="text-sm font-bold text-indigo-400">K</span>
	</div>
}

type MessageBubbleProps struct {
	Content   string
	Role      string // "user" or "assistant"
	IsLoading bool   // For streaming AI responses
	ID        string // Message ID for actions (optional, only for AI messages)
	SessionID string // Session ID for feedback endpoint (optional)
	CSRFToken string // CSRF token for feedback buttons (optional, required for actions)
}

// MessageBubble renders a chat message bubble.
// User messages: right-aligned, indigo background
// AI messages: left-aligned, gray background with avatar
templ MessageBubble(props MessageBubbleProps) {
	if props.Role == "user" {
		@UserMessage(props.Content)
	} else {
		@AIMessage(props.Content, props.IsLoading, props.ID, props.SessionID, props.CSRFToken)
	}
}

// UserMessage renders a user message bubble (right-aligned).
// Design: gradient background with shadow, role label above message
templ UserMessage(content string) {
	<div class="group flex gap-3 justify-end">
		<div class="flex flex-col items-end gap-1 max-w-[90%] sm:max-w-[80%] md:max-w-[70%]">
			<!-- Role label -->
			<span class="text-xs text-gray-400 font-medium mr-1">You</span>
			<!-- Message bubble -->
			<div class="rounded-2xl rounded-tr-sm bg-gradient-to-br from-indigo-500 to-indigo-600 px-4 py-3 text-white shadow-md group-hover:shadow-lg transition-shadow duration-200">
				<p class="text-sm whitespace-pre-wrap">{ content }</p>
			</div>
		</div>
	</div>
}

// AIMessage renders an AI message bubble (left-aligned with avatar).
// Design: semi-transparent bg with ring, skeleton loader for streaming
// msgID, sessionID, and csrfToken are optional, used for action buttons
templ AIMessage(content string, isLoading bool, msgID string, sessionID string, csrfToken string) {
	<div class="group flex gap-3" { messageIDAttrs(msgID)... }>
		@AIAvatar()
		<!-- Message Content -->
		<div class="flex-1 max-w-[90%] sm:max-w-[80%] md:max-w-[70%]">
			<!-- Role label -->
			<span class="text-xs text-gray-400 font-medium mb-1 block">Koopa</span>
			<div class="rounded-2xl rounded-tl-sm bg-gray-700/50 px-4 py-3 text-white ring-1 ring-white/10 backdrop-blur-sm group-hover:bg-gray-700/70 transition-colors duration-200">
				if isLoading {
					@SkeletonLoader()
				} else if content == "" {
					<!-- Empty state while waiting for stream -->
					<div class="h-4 w-4"></div>
				} else {
					<p class="text-sm whitespace-pre-wrap prose prose-invert prose-sm max-w-none">{ content }</p>
				}
			</div>
			<!-- Message Actions -->
			if !isLoading && content != "" {
				@MessageActions(msgID, sessionID, content, csrfToken)
			}
		</div>
	</div>
}

// MessageActions renders copy and feedback buttons for AI messages.
// Always visible for better discoverability and accessibility.
// All buttons have focus-visible ring for keyboard accessibility.
// csrfToken is required for feedback POST requests (CSRF protection).
templ MessageActions(msgID string, sessionID string, content string, csrfToken string) {
	<div class="flex items-center gap-1 mt-2" role="group" aria-label="Message actions">
		<!-- Copy button -->
		<button
			type="button"
			class="p-1.5 rounded-md text-gray-400 hover:text-white hover:bg-white/10 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900"
			aria-label="Copy message"
			data-copy-content={ content }
		>
			<svg class="size-4 transition-colors" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M8 4v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7.242a2 2 0 0 0-.602-1.43L16.083 2.57A2 2 0 0 0 14.685 2H10a2 2 0 0 0-2 2Z" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M16 18v2a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h2" stroke-linecap="round" stroke-linejoin="round"></path>
			</svg>
		</button>
		<!-- Thumbs up -->
		if msgID != "" && sessionID != "" && csrfToken != "" {
			<button
				type="button"
				class="p-1.5 rounded-md text-gray-400 hover:text-green-400 hover:bg-green-500/10 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-green-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900"
				aria-label="Good response"
				hx-post={ "/genui/feedback/" + msgID + "?type=up" }
				hx-vals={ csrfVals(csrfToken) }
				hx-swap="none"
			>
				<svg class="size-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M7 10v12m8-16.12L14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.68a2 2 0 0 0 1.6-.8l4.48-5.96a1 1 0 0 1 1.76.52L15 5.88Z" stroke-linecap="round" stroke-linejoin="round"></path>
				</svg>
			</button>
			<!-- Thumbs down -->
			<button
				type="button"
				class="p-1.5 rounded-md text-gray-400 hover:text-red-400 hover:bg-red-500/10 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-red-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900"
				aria-label="Bad response"
				hx-post={ "/genui/feedback/" + msgID + "?type=down" }
				hx-vals={ csrfVals(csrfToken) }
				hx-swap="none"
			>
				<svg class="size-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M17 14V2m-8 16.12L10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.68a2 2 0 0 0-1.6.8l-4.48 5.96a1 1 0 0 1-1.76-.52L9 18.12Z" stroke-linecap="round" stroke-linejoin="round"></path>
				</svg>
			</button>
			<!-- Regenerate -->
			<button
				type="button"
				class="p-1.5 rounded-md text-gray-400 hover:text-indigo-400 hover:bg-indigo-500/10 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900"
				aria-label="Regenerate response"
				hx-post={ "/genui/regenerate/" + msgID }
				hx-vals={ csrfVals(csrfToken) }
				hx-target={ "#message-" + msgID }
				hx-swap="outerHTML"
				hx-indicator={ "#regenerate-spinner-" + msgID }
			>
				<svg id={ "regenerate-spinner-" + msgID } class="size-4 htmx-indicator animate-spin" viewBox="0 0 24 24" fill="none">
					<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
					<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
				</svg>
				<svg class="size-4 htmx-hide-on-request" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" stroke-linecap="round" stroke-linejoin="round"></path>
					<path d="M21 3v5h-5" stroke-linecap="round" stroke-linejoin="round"></path>
				</svg>
			</button>
		}
	</div>
}

// AIMessageStreaming renders an AI message that will receive streaming content via SSE.
// The content will be updated in real-time using HTMX SSE extension.
// messageID: unique ID for this message (used for SSE swap targeting)
// sessionID: current session ID (required for SSE endpoint)
// query: the user's message to send to the AI (URL-encoded in SSE connect URL)
// Includes ARIA live region for screen reader accessibility.
//
// SSE Architecture (per HTMX Master review):
// - Client uses sse-swap="chunk" to listen for "chunk" events
// - Server sends plain HTML content in "chunk" events
// - hx-swap="innerHTML" replaces skeleton with streamed content
// - sse-close="done" closes connection when "done" event received
//
// Tool Event Feedback
// - Tool indicator is placed as SIBLING above message bubble (per htmx-master)
// - Uses message-scoped ID: tool-indicator-{messageID} for concurrent tools
// - Updated via SSE OOB swap when tool execution starts/completes/fails
// - empty:hidden CSS class hides the div when empty
templ AIMessageStreaming(messageID string, sessionID string, query string) {
	<!-- Container for message group with tool indicator -->
	<div class="space-y-2">
		<!-- Tool indicator placeholder (sibling, above message) -->
		<!-- Per htmx-master: Message-scoped ID for concurrent tools -->
		<!-- Populated via SSE OOB swap during tool execution -->
		<div
			id={ "tool-indicator-" + messageID }
			role="status"
			aria-live="polite"
			class="empty:hidden"
		>
			<!-- Populated via SSE OOB swap when tools execute -->
		</div>
		<!-- AI message bubble -->
		<div class="group flex gap-3" id={ "message-" + messageID }>
			@AIAvatar()
			<!-- Message Content (will be populated by SSE) -->
			<div class="flex-1 max-w-[90%] sm:max-w-[80%] md:max-w-[70%]">
				<!-- Role label -->
				<span class="text-xs text-gray-400 font-medium mb-1 block">Koopa</span>
				<div class="rounded-2xl rounded-tl-sm bg-gray-700/50 px-4 py-3 text-white ring-1 ring-white/10 backdrop-blur-sm group-hover:bg-gray-700/70 transition-colors duration-200">
					<!-- Streaming content with SSE event handling -->
					<!-- sse-swap="chunk" listens for "chunk" events and swaps content into this div -->
					<!-- Query is passed via URL parameter (URL-encoded) -->
					<div
						id={ "msg-content-" + messageID }
						class="text-sm whitespace-pre-wrap prose prose-invert prose-sm max-w-none sse-content"
						aria-live="polite"
						aria-atomic="false"
						hx-ext="sse"
						sse-connect={ buildSSEConnectURL(messageID, sessionID, query) }
						sse-swap="chunk"
						hx-swap="innerHTML transition:true"
						sse-close="done"
					>
						@SkeletonLoader()
					</div>
				</div>
			</div>
		</div>
	</div>
}
