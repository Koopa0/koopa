package ui

import (
	"bufio"
	"fmt"
	"io"
	"strings"
)

// Console implements the IO interface for terminal interaction.
type Console struct {
	in      io.Reader
	out     io.Writer
	scanner *bufio.Scanner
}

// NewConsole creates a new Console instance.
func NewConsole(in io.Reader, out io.Writer) *Console {
	return &Console{
		in:      in,
		out:     out,
		scanner: bufio.NewScanner(in),
	}
}

// Print prints arguments to the output.
func (c *Console) Print(a ...any) {
	fmt.Fprint(c.out, a...)
}

// Println prints arguments to the output ending with a newline.
func (c *Console) Println(a ...any) {
	fmt.Fprintln(c.out, a...)
}

// Printf prints formatted output.
func (c *Console) Printf(format string, a ...any) {
	fmt.Fprintf(c.out, format, a...)
}

// Scan advances the scanner to the next token.
func (c *Console) Scan() bool {
	return c.scanner.Scan()
}

// Text returns the most recent token generated by a call to Scan.
func (c *Console) Text() string {
	return c.scanner.Text()
}

// Confirm prompts the user for a yes/no confirmation.
func (c *Console) Confirm(prompt string) (bool, error) {
	for {
		c.Print(prompt + " [y/n]: ")

		// Ensure output is flushed if it's a buffered writer (like stdout often is)
		if syncer, ok := c.out.(interface{ Sync() error }); ok {
			_ = syncer.Sync()
		}

		if !c.Scan() {
			if err := c.scanner.Err(); err != nil {
				return false, err
			}
			return false, io.EOF
		}

		input := strings.ToLower(strings.TrimSpace(c.Text()))
		if input == "y" || input == "yes" {
			return true, nil
		} else if input == "n" || input == "no" {
			return false, nil
		} else {
			c.Println("Invalid input. Please enter 'y' or 'n'.")
		}
	}
}

// Stream displays streaming content.
func (c *Console) Stream(content string) {
	c.Print(content)
	// Ensure output is flushed immediately for smooth streaming
	if syncer, ok := c.out.(interface{ Sync() error }); ok {
		_ = syncer.Sync()
	}
}
