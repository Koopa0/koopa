// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: documents.sql

package sqlc

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const countDocuments = `-- name: CountDocuments :one
SELECT COUNT(*)
FROM documents
WHERE metadata @> $1::jsonb
`

func (q *Queries) CountDocuments(ctx context.Context, dollar_1 []byte) (int64, error) {
	row := q.db.QueryRow(ctx, countDocuments, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDocumentsAll = `-- name: CountDocumentsAll :one
SELECT COUNT(*)
FROM documents
`

func (q *Queries) CountDocumentsAll(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDocumentsAll)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents
WHERE id = $1
`

func (q *Queries) DeleteDocument(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteDocument, id)
	return err
}

const getDocument = `-- name: GetDocument :one
SELECT id, content, metadata
FROM documents
WHERE id = $1
`

type GetDocumentRow struct {
	ID       string `json:"id"`
	Content  string `json:"content"`
	Metadata []byte `json:"metadata"`
}

func (q *Queries) GetDocument(ctx context.Context, id string) (GetDocumentRow, error) {
	row := q.db.QueryRow(ctx, getDocument, id)
	var i GetDocumentRow
	err := row.Scan(&i.ID, &i.Content, &i.Metadata)
	return i, err
}

const listDocumentsBySourceType = `-- name: ListDocumentsBySourceType :many
SELECT id, content, metadata
FROM documents
WHERE source_type = $1::text
LIMIT $2
`

type ListDocumentsBySourceTypeParams struct {
	SourceType  string `json:"source_type"`
	ResultLimit int32  `json:"result_limit"`
}

type ListDocumentsBySourceTypeRow struct {
	ID       string `json:"id"`
	Content  string `json:"content"`
	Metadata []byte `json:"metadata"`
}

// List all documents by source_type using dedicated indexed column
// Used for listing indexed files without needing embeddings
func (q *Queries) ListDocumentsBySourceType(ctx context.Context, arg ListDocumentsBySourceTypeParams) ([]ListDocumentsBySourceTypeRow, error) {
	rows, err := q.db.Query(ctx, listDocumentsBySourceType, arg.SourceType, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDocumentsBySourceTypeRow{}
	for rows.Next() {
		var i ListDocumentsBySourceTypeRow
		if err := rows.Scan(&i.ID, &i.Content, &i.Metadata); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBySourceType = `-- name: SearchBySourceType :many

SELECT id, content, metadata,
       (1 - (embedding <=> $1::vector))::float8 AS similarity
FROM documents
WHERE source_type = $2::text
ORDER BY similarity DESC
LIMIT $3
`

type SearchBySourceTypeParams struct {
	QueryEmbedding *pgvector.Vector `json:"query_embedding"`
	SourceType     string           `json:"source_type"`
	ResultLimit    int32            `json:"result_limit"`
}

type SearchBySourceTypeRow struct {
	ID         string  `json:"id"`
	Content    string  `json:"content"`
	Metadata   []byte  `json:"metadata"`
	Similarity float64 `json:"similarity"`
}

// ===== Optimized RAG Queries (SQL-level filtering) =====
// Generic search by source_type using dedicated indexed column
func (q *Queries) SearchBySourceType(ctx context.Context, arg SearchBySourceTypeParams) ([]SearchBySourceTypeRow, error) {
	rows, err := q.db.Query(ctx, searchBySourceType, arg.QueryEmbedding, arg.SourceType, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBySourceTypeRow{}
	for rows.Next() {
		var i SearchBySourceTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDocuments = `-- name: SearchDocuments :many
SELECT id, content, metadata,
       (1 - (embedding <=> $1::vector))::float8 AS similarity
FROM documents
WHERE metadata @> $2::jsonb
ORDER BY similarity DESC
LIMIT $3
`

type SearchDocumentsParams struct {
	QueryEmbedding *pgvector.Vector `json:"query_embedding"`
	FilterMetadata []byte           `json:"filter_metadata"`
	ResultLimit    int32            `json:"result_limit"`
}

type SearchDocumentsRow struct {
	ID         string  `json:"id"`
	Content    string  `json:"content"`
	Metadata   []byte  `json:"metadata"`
	Similarity float64 `json:"similarity"`
}

func (q *Queries) SearchDocuments(ctx context.Context, arg SearchDocumentsParams) ([]SearchDocumentsRow, error) {
	rows, err := q.db.Query(ctx, searchDocuments, arg.QueryEmbedding, arg.FilterMetadata, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDocumentsRow{}
	for rows.Next() {
		var i SearchDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDocumentsAll = `-- name: SearchDocumentsAll :many
SELECT id, content, metadata,
       (1 - (embedding <=> $1::vector))::float8 AS similarity
FROM documents
ORDER BY similarity DESC
LIMIT $2
`

type SearchDocumentsAllParams struct {
	QueryEmbedding *pgvector.Vector `json:"query_embedding"`
	ResultLimit    int32            `json:"result_limit"`
}

type SearchDocumentsAllRow struct {
	ID         string  `json:"id"`
	Content    string  `json:"content"`
	Metadata   []byte  `json:"metadata"`
	Similarity float64 `json:"similarity"`
}

func (q *Queries) SearchDocumentsAll(ctx context.Context, arg SearchDocumentsAllParams) ([]SearchDocumentsAllRow, error) {
	rows, err := q.db.Query(ctx, searchDocumentsAll, arg.QueryEmbedding, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDocumentsAllRow{}
	for rows.Next() {
		var i SearchDocumentsAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDocument = `-- name: UpsertDocument :exec

INSERT INTO documents (id, content, embedding, source_type, metadata)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    content = EXCLUDED.content,
    embedding = EXCLUDED.embedding,
    source_type = EXCLUDED.source_type,
    metadata = EXCLUDED.metadata
`

type UpsertDocumentParams struct {
	ID         string           `json:"id"`
	Content    string           `json:"content"`
	Embedding  *pgvector.Vector `json:"embedding"`
	SourceType *string          `json:"source_type"`
	Metadata   []byte           `json:"metadata"`
}

// Documents queries for sqlc
// Generated code will be in internal/sqlc/documents.sql.go
func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) error {
	_, err := q.db.Exec(ctx, upsertDocument,
		arg.ID,
		arg.Content,
		arg.Embedding,
		arg.SourceType,
		arg.Metadata,
	)
	return err
}
