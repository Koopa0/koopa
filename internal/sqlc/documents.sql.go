// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: documents.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const countDocuments = `-- name: CountDocuments :one
SELECT COUNT(*)
FROM documents
WHERE metadata @> $1::jsonb
`

func (q *Queries) CountDocuments(ctx context.Context, dollar_1 []byte) (int64, error) {
	row := q.db.QueryRow(ctx, countDocuments, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDocumentsAll = `-- name: CountDocumentsAll :one
SELECT COUNT(*)
FROM documents
`

func (q *Queries) CountDocumentsAll(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDocumentsAll)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents
WHERE id = $1
`

func (q *Queries) DeleteDocument(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteDocument, id)
	return err
}

const getDocument = `-- name: GetDocument :one
SELECT id, content, metadata, created_at, updated_at
FROM documents
WHERE id = $1
`

type GetDocumentRow struct {
	ID        string             `json:"id"`
	Content   string             `json:"content"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetDocument(ctx context.Context, id string) (GetDocumentRow, error) {
	row := q.db.QueryRow(ctx, getDocument, id)
	var i GetDocumentRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDocumentsBySourceType = `-- name: ListDocumentsBySourceType :many
SELECT id, content, metadata, created_at, updated_at
FROM documents
WHERE metadata->>'source_type' = $1::text
ORDER BY created_at DESC
LIMIT $2
`

type ListDocumentsBySourceTypeParams struct {
	SourceType  string `json:"source_type"`
	ResultLimit int    `json:"result_limit"`
}

type ListDocumentsBySourceTypeRow struct {
	ID        string             `json:"id"`
	Content   string             `json:"content"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// List all documents by source_type without similarity calculation
// Used for listing indexed files without needing embeddings
func (q *Queries) ListDocumentsBySourceType(ctx context.Context, arg ListDocumentsBySourceTypeParams) ([]ListDocumentsBySourceTypeRow, error) {
	rows, err := q.db.Query(ctx, listDocumentsBySourceType, arg.SourceType, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDocumentsBySourceTypeRow{}
	for rows.Next() {
		var i ListDocumentsBySourceTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBySourceType = `-- name: SearchBySourceType :many

SELECT id, content, metadata, created_at,
       (1 - (embedding <=> $1::vector))::float AS similarity
FROM documents
WHERE metadata->>'source_type' = $2::text
ORDER BY similarity DESC
LIMIT $3
`

type SearchBySourceTypeParams struct {
	QueryEmbedding *pgvector.Vector `json:"query_embedding"`
	SourceType     string           `json:"source_type"`
	ResultLimit    int              `json:"result_limit"`
}

type SearchBySourceTypeRow struct {
	ID         string             `json:"id"`
	Content    string             `json:"content"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Similarity float64            `json:"similarity"`
}

// ===== Optimized RAG Queries (SQL-level filtering) =====
// Generic search by source_type (flexible for future source types)
func (q *Queries) SearchBySourceType(ctx context.Context, arg SearchBySourceTypeParams) ([]SearchBySourceTypeRow, error) {
	rows, err := q.db.Query(ctx, searchBySourceType, arg.QueryEmbedding, arg.SourceType, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBySourceTypeRow{}
	for rows.Next() {
		var i SearchBySourceTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDocuments = `-- name: SearchDocuments :many
SELECT id, content, metadata, created_at,
       (1 - (embedding <=> $1::vector))::float AS similarity
FROM documents
WHERE metadata @> $2::jsonb
ORDER BY similarity DESC
LIMIT $3
`

type SearchDocumentsParams struct {
	QueryEmbedding *pgvector.Vector `json:"query_embedding"`
	FilterMetadata []byte           `json:"filter_metadata"`
	ResultLimit    int              `json:"result_limit"`
}

type SearchDocumentsRow struct {
	ID         string             `json:"id"`
	Content    string             `json:"content"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Similarity float64            `json:"similarity"`
}

func (q *Queries) SearchDocuments(ctx context.Context, arg SearchDocumentsParams) ([]SearchDocumentsRow, error) {
	rows, err := q.db.Query(ctx, searchDocuments, arg.QueryEmbedding, arg.FilterMetadata, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDocumentsRow{}
	for rows.Next() {
		var i SearchDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDocumentsAll = `-- name: SearchDocumentsAll :many
SELECT id, content, metadata, created_at,
       (1 - (embedding <=> $1::vector))::float AS similarity
FROM documents
ORDER BY similarity DESC
LIMIT $2
`

type SearchDocumentsAllParams struct {
	QueryEmbedding *pgvector.Vector `json:"query_embedding"`
	ResultLimit    int              `json:"result_limit"`
}

type SearchDocumentsAllRow struct {
	ID         string             `json:"id"`
	Content    string             `json:"content"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Similarity float64            `json:"similarity"`
}

func (q *Queries) SearchDocumentsAll(ctx context.Context, arg SearchDocumentsAllParams) ([]SearchDocumentsAllRow, error) {
	rows, err := q.db.Query(ctx, searchDocumentsAll, arg.QueryEmbedding, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDocumentsAllRow{}
	for rows.Next() {
		var i SearchDocumentsAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDocument = `-- name: UpsertDocument :exec

INSERT INTO documents (id, content, embedding, metadata, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW())
ON CONFLICT (id) DO UPDATE SET
    content = EXCLUDED.content,
    embedding = EXCLUDED.embedding,
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
`

type UpsertDocumentParams struct {
	ID        string             `json:"id"`
	Content   string             `json:"content"`
	Embedding *pgvector.Vector   `json:"embedding"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Documents queries for sqlc
// Generated code will be in internal/sqlc/documents.sql.go
func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) error {
	_, err := q.db.Exec(ctx, upsertDocument,
		arg.ID,
		arg.Content,
		arg.Embedding,
		arg.Metadata,
		arg.CreatedAt,
	)
	return err
}
