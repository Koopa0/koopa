// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: artifacts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteArtifactByFilename = `-- name: DeleteArtifactByFilename :execrows
DELETE FROM artifact
WHERE session_id = $1 AND filename = $2
`

type DeleteArtifactByFilenameParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	Filename  string      `json:"filename"`
}

// Delete artifact by session and filename
func (q *Queries) DeleteArtifactByFilename(ctx context.Context, arg DeleteArtifactByFilenameParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteArtifactByFilename, arg.SessionID, arg.Filename)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteArtifactsBySession = `-- name: DeleteArtifactsBySession :exec
DELETE FROM artifact
WHERE session_id = $1
`

// Delete all artifacts for a session (called when session is deleted)
func (q *Queries) DeleteArtifactsBySession(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteArtifactsBySession, sessionID)
	return err
}

const getArtifactByFilename = `-- name: GetArtifactByFilename :one
SELECT id, session_id, message_id, type, language, title, content, version, sequence_number, created_at, updated_at, filename
FROM artifact
WHERE session_id = $1 AND filename = $2
`

type GetArtifactByFilenameParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	Filename  string      `json:"filename"`
}

// Get artifact by session and filename
func (q *Queries) GetArtifactByFilename(ctx context.Context, arg GetArtifactByFilenameParams) (Artifact, error) {
	row := q.db.QueryRow(ctx, getArtifactByFilename, arg.SessionID, arg.Filename)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.MessageID,
		&i.Type,
		&i.Language,
		&i.Title,
		&i.Content,
		&i.Version,
		&i.SequenceNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Filename,
	)
	return i, err
}

const listArtifactFilenames = `-- name: ListArtifactFilenames :many
SELECT filename
FROM artifact
WHERE session_id = $1
ORDER BY sequence_number ASC
`

// List all artifact filenames for a session
func (q *Queries) ListArtifactFilenames(ctx context.Context, sessionID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listArtifactFilenames, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var filename string
		if err := rows.Scan(&filename); err != nil {
			return nil, err
		}
		items = append(items, filename)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveArtifact = `-- name: SaveArtifact :one

INSERT INTO artifact (
    session_id,
    message_id,
    filename,
    type,
    language,
    title,
    content,
    version,
    sequence_number
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, 1,
    COALESCE((SELECT MAX(sequence_number) FROM artifact WHERE session_id = $1), 0) + 1
)
ON CONFLICT (session_id, filename) DO UPDATE SET
    message_id = EXCLUDED.message_id,
    type = EXCLUDED.type,
    language = EXCLUDED.language,
    title = EXCLUDED.title,
    content = EXCLUDED.content,
    version = artifact.version + 1,
    updated_at = NOW()
RETURNING id, session_id, message_id, type, language, title, content, version, sequence_number, created_at, updated_at, filename
`

type SaveArtifactParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	MessageID pgtype.UUID `json:"message_id"`
	Filename  string      `json:"filename"`
	Type      string      `json:"type"`
	Language  *string     `json:"language"`
	Title     string      `json:"title"`
	Content   string      `json:"content"`
}

// Artifact queries for sqlc
// Table: artifact (renamed from session_artifacts in migration 000006)
// Added: filename column (migration 000007)
// UPSERT artifact by (session_id, filename)
// If exists, updates content and increments version
func (q *Queries) SaveArtifact(ctx context.Context, arg SaveArtifactParams) (Artifact, error) {
	row := q.db.QueryRow(ctx, saveArtifact,
		arg.SessionID,
		arg.MessageID,
		arg.Filename,
		arg.Type,
		arg.Language,
		arg.Title,
		arg.Content,
	)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.MessageID,
		&i.Type,
		&i.Language,
		&i.Title,
		&i.Content,
		&i.Version,
		&i.SequenceNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Filename,
	)
	return i, err
}
