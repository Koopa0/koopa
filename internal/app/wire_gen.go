// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"context"
	"fmt"
	"github.com/firebase/genkit/go/ai"
	"github.com/firebase/genkit/go/genkit"
	"github.com/firebase/genkit/go/plugins/googlegenai"
	"github.com/google/wire"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/koopa0/koopa-cli/db"
	"github.com/koopa0/koopa-cli/internal/config"
	"github.com/koopa0/koopa-cli/internal/knowledge"
	"github.com/koopa0/koopa-cli/internal/observability"
	"github.com/koopa0/koopa-cli/internal/security"
	"github.com/koopa0/koopa-cli/internal/session"
	"github.com/koopa0/koopa-cli/internal/sqlc"
	"log/slog"
	"time"
)

// Injectors from wire.go:

// InitializeApp is the Wire injector function.
// Wire will automatically generate the implementation of this function.
func InitializeApp(ctx context.Context, cfg *config.Config) (*App, func(), error) {
	otelShutdown, cleanup, err := provideOtelShutdown(ctx, cfg)
	if err != nil {
		return nil, nil, err
	}
	genkit, err := provideGenkit(ctx, cfg, otelShutdown)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	embedder := provideEmbedder(genkit, cfg)
	pool, cleanup2, err := provideDBPool(ctx, cfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	store := provideKnowledgeStore(pool, embedder)
	sessionStore := provideSessionStore(pool)
	path, err := providePathValidator()
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	logger := provideLogger()
	systemKnowledgeIndexer := knowledge.NewSystemKnowledgeIndexer(store, logger)
	app, err := newApp(cfg, ctx, genkit, embedder, pool, store, sessionStore, path, systemKnowledgeIndexer)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	return app, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// OtelShutdown is a cleanup function for OpenTelemetry resources.
// Type alias provides clear semantics for Wire dependency ordering.
type OtelShutdown func()

// providerSet contains all providers.
var providerSet = wire.NewSet(

	provideOtelShutdown,
	provideGenkit,
	provideEmbedder,
	provideDBPool,
	provideKnowledgeStore,
	provideSessionStore,
	providePathValidator,
	provideLogger, knowledge.NewSystemKnowledgeIndexer, newApp,
)

// provideOtelShutdown sets up Datadog tracing before Genkit initialization.
// Must be called before provideGenkit to ensure TracerProvider is ready.
// Returns OtelShutdown (for Wire dependency) and cleanup func (for Wire cleanup chain).
func provideOtelShutdown(ctx context.Context, cfg *config.Config) (OtelShutdown, func(), error) {
	shutdown, err := observability.SetupDatadog(ctx, observability.Config{
		AgentHost:   cfg.Datadog.AgentHost,
		Environment: cfg.Datadog.Environment,
		ServiceName: cfg.Datadog.ServiceName,
	})
	if err != nil {
		return nil, nil, err
	}

	cleanupFn := func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		if err := shutdown(shutdownCtx); err != nil {
			slog.Warn("failed to shutdown tracer provider", "error", err)
		}
	}

	return OtelShutdown(cleanupFn), cleanupFn, nil
}

// provideGenkit initializes Genkit with Google AI plugin and prompt directory.
// Returns error if initialization fails (follows Wire provider pattern).
// Depends on OtelShutdown to ensure tracing is set up first.
func provideGenkit(ctx context.Context, cfg *config.Config, _ OtelShutdown) (*genkit.Genkit, error) {

	promptDir := cfg.PromptDir
	if promptDir == "" {
		promptDir = "prompts"
	}

	g := genkit.Init(ctx, genkit.WithPlugins(&googlegenai.GoogleAI{}), genkit.WithPromptDir(promptDir))

	if g == nil {
		return nil, fmt.Errorf("failed to initialize Genkit")
	}

	return g, nil
}

// provideEmbedder creates an embedder instance.
func provideEmbedder(g *genkit.Genkit, cfg *config.Config) ai.Embedder {
	return googlegenai.GoogleAIEmbedder(g, cfg.EmbedderModel)
}

// provideDBPool creates a PostgreSQL connection pool and runs migrations.
// Pool is configured with sensible defaults for connection management.
func provideDBPool(ctx context.Context, cfg *config.Config) (*pgxpool.Pool, func(), error) {

	if err := db.Migrate(cfg.PostgresURL()); err != nil {
		return nil, nil, fmt.Errorf("failed to run migrations: %w", err)
	}

	poolCfg, err := pgxpool.ParseConfig(cfg.PostgresConnectionString())
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse connection config: %w", err)
	}

	poolCfg.MaxConns = 10
	poolCfg.MinConns = 2
	poolCfg.MaxConnLifetime = 30 * time.Minute
	poolCfg.MaxConnIdleTime = 5 * time.Minute
	poolCfg.HealthCheckPeriod = 1 * time.Minute

	pool, err := pgxpool.NewWithConfig(ctx, poolCfg)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create connection pool: %w", err)
	}

	pingCtx, pingCancel := context.WithTimeout(ctx, 5*time.Second)
	defer pingCancel()
	if err := pool.Ping(pingCtx); err != nil {
		pool.Close()
		return nil, nil, fmt.Errorf("failed to ping database: %w", err)
	}

	cleanup := func() {
		pool.Close()
	}

	return pool, cleanup, nil
}

// provideKnowledgeStore creates a knowledge store instance.
func provideKnowledgeStore(pool *pgxpool.Pool, embedder ai.Embedder) *knowledge.Store {
	return knowledge.New(sqlc.New(pool), embedder, nil)
}

// provideSessionStore creates a session store instance.
// This provides real session persistence using PostgreSQL backend.
func provideSessionStore(pool *pgxpool.Pool) *session.Store {
	return session.New(sqlc.New(pool), pool, nil)
}

// providePathValidator creates a path validator instance.
func providePathValidator() (*security.Path, error) {

	return security.NewPath([]string{"."})
}

// provideLogger creates a logger instance.
// Returns slog.Default() for consistent logging across the application.
func provideLogger() *slog.Logger {
	return slog.Default()
}

// newApp constructs an App instance.
// Wire automatically injects all dependencies.
func newApp(
	cfg *config.Config,
	ctx context.Context,
	g *genkit.Genkit,
	embedder ai.Embedder,
	pool *pgxpool.Pool,
	knowledgeStore *knowledge.Store,
	sessionStore *session.Store,
	pathValidator *security.Path,
	systemIndexer *knowledge.SystemKnowledgeIndexer,
) (*App, error) {

	appCtx, cancel := context.WithCancel(ctx)

	app := &App{
		Config:        cfg,
		ctx:           appCtx,
		cancel:        cancel,
		Genkit:        g,
		Embedder:      embedder,
		DBPool:        pool,
		Knowledge:     knowledgeStore,
		SessionStore:  sessionStore,
		PathValidator: pathValidator,
		SystemIndexer: systemIndexer,
	}

	go func() {

		indexCtx, indexCancel := context.WithTimeout(appCtx, 5*time.Second)
		defer indexCancel()

		count, err := systemIndexer.IndexAll(indexCtx)
		if err != nil {
			slog.Debug("system knowledge indexing failed (non-critical)", "error", err)
		} else {
			slog.Debug("system knowledge indexed successfully", "count", count)
		}
	}()

	return app, nil
}
